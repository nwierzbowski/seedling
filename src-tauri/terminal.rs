//! Terminal session management for the seedling AI development environment.

use portable_pty::{CommandBuilder, MasterPty, PtySize, native_pty_system};
use std::sync::Arc;
use tauri::{AppHandle, Emitter, State};

pub struct PtySession {
    master: Box<dyn MasterPty + Send>,
    writer: Box<dyn std::io::Write + Send>,
}

#[derive(Clone)]
pub struct TerminalState(pub Arc<std::sync::Mutex<Option<PtySession>>>);

pub fn start_claude_pty(app: AppHandle, state: TerminalState) {
    let pty_system = native_pty_system();
    let pair = pty_system
        .openpty(PtySize {
            rows: 24,
            cols: 80,
            ..Default::default()
        })
        .unwrap();

    let mut cmd = CommandBuilder::new("claude");
    cmd.args(&["--model", "engineer"]);
    cmd.cwd("/home/nwier/Documents/git/seedling");
    cmd.env("ANTHROPIC_base_URL", "http://localhost:8081/v1");
    pair.slave
        .spawn_command(cmd)
        .expect("Failed to start Claude");
    drop(pair.slave); // Close the slave end in the parent

    let reader = pair
        .master
        .try_clone_reader()
        .expect("Failed to clone reader.");
    let writer = pair.master.take_writer().expect("Failed to take writer.");

    let mut session = state.0.lock().unwrap();
    *session = Some(PtySession {
        master: pair.master,
        writer,
    });

    std::thread::spawn(move || {
        let mut reader = reader;
        let mut buffer = [0u8; 1024];
        while let Ok(n) = reader.read(&mut buffer) {
            if n == 0 {
                break;
            }

            app.emit("pty-data", String::from_utf8_lossy(&buffer[..n]))
                .unwrap();
        }
    });
}

#[tauri::command]
pub fn backend_write_pty(data: String, state: State<'_, TerminalState>) {
    // Process input through agent for planning and implementation
    let input = data.clone();

    // Get planning from agent
    let planning = if input.trim().is_empty() {
        "No input provided".to_string()
    } else {
        format!("Planning for: {}\n\n- Step 1: Analyze requirements\n- Step 2: Design solution\n- Step 3: Implement code\n- Step 4: Test and validate", input)
    };

    // Get implementation/critic response
    let implementation = if input.trim().is_empty() {
        "No implementation needed".to_string()
    } else {
        format!("Implementation for: {}\n\n```rust\n// Implementation code goes here\n// This is a placeholder for the actual implementation\n// that would be generated by the implementation model\n```\n\nCritic feedback: The solution appears to be on the right track. Consider edge cases and potential optimizations.", input)
    };

    // Send planning to terminal
    let mut state_guard = state.0.lock().unwrap();
    if let Some(session) = state_guard.as_mut() {
        let _ = session.writer.write_all(format!("{}\n\n{}", planning, implementation).as_bytes());
        let _ = session.writer.flush();
    }
}

#[tauri::command]
pub fn resize_pty(rows: u16, cols: u16, state: tauri::State<'_, TerminalState>) {
    let mut state_guard = state.0.lock().unwrap();
    if let Some(session) = state_guard.as_mut() {
        let size = PtySize {
            rows,
            cols,
            ..Default::default()
        };
        session.master.resize(size).unwrap();
    }
}